# @opencanon/canon

Validation toolkit for shared fiction worldbuilding. CLI + library.

- **CLI binary**: `canon` — scaffold repos, run compliance checks, generate lock files
- **Library**: pure validation core + adapters (filesystem, GitHub)
- **Schema**: metadata v1.2, check report v2

---

## Install

```bash
npm install -g @opencanon/canon   # CLI (global)
npm install @opencanon/canon      # Library (local)
```

---

## CLI Commands

| Command | Description | Exit code |
|---|---|---|
| `canon init [dir]` | Scaffold repo: `canon/`, `stories/`, `.canonrc.json`, `CONVENTIONS.md` | 0 |
| `canon new story <id>` | Create `stories/<id>/metadata.json` from template | 0 or 1 |
| `canon new character <id>` | Create `canon/characters/<id>/definition.json` | 0 or 1 |
| `canon new location <id>` | Create `canon/worldbuilding/locations/<id>.json` | 0 or 1 |
| `canon check [dir]` | Run all compliance checks. **0** = all pass, **1** = any fail or no stories | 0 or 1 |
| `canon lock [dir]` | Run compliance pre-check, then regenerate `canon.lock.json`. Genesis lock skips pre-check. | 0 or 1 |

ID constraint: `/^[a-z0-9][a-z0-9_-]*$/` — lowercase alphanumeric, hyphens, underscores.

---

## Compliance Checks

Seven checks run per story. Check IDs are stable (additive-only, never removed).

| Check ID | Rule |
|---|---|
| `metadata_schema_valid` | Required fields present, correct types, `schema_version === "1.2"` |
| `characters_valid` | Every `characters[]` entry exists in `canon/characters/` |
| `locations_valid` | Every `locations[]` entry exists in `canon/worldbuilding/locations/` |
| `timeline_consistent` | `timeline` is strict ISO date `YYYY-MM-DD`, round-trip validated |
| `continuity_valid` | `temporal_context.prev_episode`, `next_episode`, `thematic_echoes` all resolve |
| `canon_version_match` | `canon_ref` matches `canon.lock.json` `canon_commit` |
| `contributor_valid` | `contributor` field is present and non-empty |

---

## Library Exports

Three entry points. Core is pure (no I/O). Adapters convert external data into `RepoModel`.

### `@opencanon/canon` — core

```ts
import {
  validateRepo,        // (model: RepoModel) => RepoCheckReport
  validateStory,       // single story validation
  checkCharacters, checkLocations, checkTimeline,
  checkContinuity, checkCanonVersion, checkContributor,
  checkMetadataSchema,
  type RepoModel, type RepoCheckReport, type StoryCheckReport,
  type CheckResult, type CheckId,
  type CanonLock, type StoryMetadata, type CanonConfig,
  type GitHubRepoInput, type GitHubTreeEntry,
} from "@opencanon/canon"
```

`RepoCheckReport.schemaVersion` is always `"check.v2"`. Includes `summary: { score, totalChecks, passingChecks }`.

### `@opencanon/canon/adapters/fs` — filesystem

```ts
import { loadRepoFromFs } from "@opencanon/canon/adapters/fs"
const model: RepoModel = loadRepoFromFs("/path/to/repo")
```

Reads `canon/`, `stories/`, `canon.lock.json` from disk. Returns `RepoModel`.

### `@opencanon/canon/adapters/github` — GitHub (pure conversion)

```ts
import { buildRepoModel } from "@opencanon/canon/adapters/github"
const model: RepoModel = buildRepoModel({ tree, files })
```

Takes pre-fetched GitHub Trees API entries + file contents. No HTTP, no Octokit. Your app fetches, this function converts.

**`GitHubRepoInput`**:
- `tree`: `{ path: string, type: "blob" | "tree", sha: string }[]`
- `files`: `Map<string, string>` — path → content for `canon.lock.json`, `stories/*/metadata.json`

---

## Repo Structure

```
<repo-root>/
├── canon/
│   ├── characters/<id>/definition.json
│   └── worldbuilding/locations/<id>.json
├── stories/<slug>/
│   ├── metadata.json          # required
│   └── chapter-*.md           # content
├── canon.lock.json            # generated by `canon lock`
├── .canonrc.json              # generated by `canon init`
└── CONVENTIONS.md             # generated by `canon init`
```

---

## Metadata Schema v1.2

```jsonc
{
  "schema_version": "1.2",         // fixed
  "canon_ref": "<commit-sha>",     // must match canon.lock.json
  "id": "episode-slug",            // unique story ID
  "episode": 1,                    // number
  "title": { "ko": "...", "en": "..." },
  "timeline": "2025-01-15",        // strict YYYY-MM-DD
  "synopsis": { "ko": "...", "en": "..." },
  "characters": ["alice", "bob"],  // must exist in canon/characters/
  "locations": ["market-square"],   // must exist in canon/worldbuilding/locations/
  "contributor": "github-username", // immutable after creation
  "canon_status": "canonical",     // "canonical" | "non-canonical"
  // optional:
  "themes": ["identity"],
  "canon_events": ["first-contact"],
  "word_count": { "ko": 3200, "en": 2800 },
  "temporal_context": {
    "prev_episode": "episode-slug-prev",
    "next_episode": null,
    "thematic_echoes": ["related-slug"]
  }
}
```

---

## Lock File

`canon.lock.json` is generated by `canon lock`. Do not edit manually.

```json
{
  "schema_version": "canon.lock.v2",
  "canon_commit": "<git-HEAD-sha>",
  "worldbuilding_hash": "<sha256-hex>",
  "hash_algo": "sha256",
  "generated_at": "2025-01-15T00:00:00.000Z",
  "contributors": ["github-username"]
}
```

Hash algorithm: for each file under `canon/` in lexicographic path order, feed `relativePath + \0 + fileBytes + \0` into SHA-256.

`canon lock` runs compliance pre-check before generating. If any story fails → lock refused (exit 1). First lock (no existing `canon.lock.json`) skips pre-check.

---

## Migration from v1.1

See [MIGRATION-v1.2.md](./MIGRATION-v1.2.md).

---

## License

MIT
